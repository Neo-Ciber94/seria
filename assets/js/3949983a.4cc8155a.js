"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[121],{6203:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>l,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var t=s(9214),i=s(5629);const r={sidebar_position:3},d="How it works?",o={id:"advanced/how-it-works",title:"How it works?",description:"In seria we represents the values that cannot be serialized by default in the form:",source:"@site/docs/advanced/how-it-works.md",sourceDirName:"advanced",slug:"/advanced/how-it-works",permalink:"/seria/docs/advanced/how-it-works",draft:!1,unlisted:!1,editUrl:"https://github.com/Neo-Ciber94/seria/website/docs/docs/advanced/how-it-works.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Custom Types",permalink:"/seria/docs/advanced/custom-types"},next:{title:"Examples",permalink:"/seria/docs/category/examples"}},a={},c=[{value:"Promises",id:"promises",level:2},{value:"Async Iterators",id:"async-iterators",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"how-it-works",children:"How it works?"}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"seria"})," we represents the values that cannot be serialized by default in the form:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$<tag><id><data>?\n"})}),"\n",(0,t.jsx)(n.p,{children:"For example this is how we represent some objects:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"value"}),(0,t.jsx)(n.th,{children:"seria"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"new Date(2024, 10, 4)"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"$D12024-11-04T04:00:00.000Z"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:'Symbol.for("Nezuko")'})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"$S2Nezuko"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"$undefined"})})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["When deserializing the look at the value and check the type by looking the ",(0,t.jsx)(n.code,{children:"tag"}),"\nand the ",(0,t.jsx)(n.code,{children:"id"})," let us know where the value is located on the ",(0,t.jsx)(n.code,{children:"json"})," string, finally the data\nis just used to restore the object."]}),"\n",(0,t.jsx)(n.h2,{id:"promises",children:"Promises"}),"\n",(0,t.jsxs)(n.p,{children:["Promises are represented as ",(0,t.jsx)(n.code,{children:"$@<id>"})," following the previous format ",(0,t.jsx)(n.code,{children:"@"})," is the tag we use for promises,\nthe ",(0,t.jsx)(n.code,{children:"id"})," is used to locate the result of the promise, when the promise is streamed and had not resolved\nthe promise will wait until the next chunks are send and then we check again if the value for the id exists to resolve the promise."]}),"\n",(0,t.jsx)(n.p,{children:"When the promise is streamed the data send have this format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'"[chunk 1]"\\n\\n\n\n"[chunk 3]"\\n\\n\n\n"[chunk 2]"\\n\\n\n\n"[chunk 4]"\\n\\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When deserializing we just split the incoming stream ",(0,t.jsx)(n.code,{children:"\\n\\n"})," and then parse each value."]}),"\n",(0,t.jsx)(n.h2,{id:"async-iterators",children:"Async Iterators"}),"\n",(0,t.jsxs)(n.p,{children:["Async iterators are represented with ",(0,t.jsx)(n.code,{children:"$#<id>"})," the ",(0,t.jsx)(n.code,{children:"id"})," let us know where the emitted item or items are located, the items always will be represented as an array."]}),"\n",(0,t.jsx)(n.p,{children:"Let's use for example a generator like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"async function* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When using ",(0,t.jsx)(n.code,{children:"stringifyAsync"})," we'll wait for all the values and the emitted json will look like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'["$#1", [1,2,3,"done"]];\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For async iterators we recommend using streaming instead, when using ",(0,t.jsx)(n.code,{children:"stringifyToStream"})," we get:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'["$#1"]\\n\\n\n\n["$#1",[1]]\\n\\n\n\n["$#1",[2]]\\n\\n\n\n["$#1",[3]]\\n\\n\n\n["$#1",["done"]]\\n\\n\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Notice the last item we emit is a string with the contents ",(0,t.jsx)(n.code,{children:'"done"'})," as you may imagine it tell us the stop point of the iterator."]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},5629:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>o});var t=s(8318);const i={},r=t.createContext(i);function d(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);