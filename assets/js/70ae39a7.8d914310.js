"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8],{3132:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>n,metadata:()=>o,toc:()=>c});var i=r(3274),t=r(9779);const n={sidebar_position:4},a="Serializing Promises",o={id:"getting-started/serializing-promises",title:"Serializing Promises",description:"Serializing promises or values containing primises.",source:"@site/docs/getting-started/serializing-promises.md",sourceDirName:"getting-started",slug:"/getting-started/serializing-promises",permalink:"/seria/docs/getting-started/serializing-promises",draft:!1,unlisted:!1,editUrl:"https://github.com/Neo-Ciber94/seria/website/docs/docs/getting-started/serializing-promises.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Supported Types",permalink:"/seria/docs/getting-started/supported-types"},next:{title:"Working with FormData",permalink:"/seria/docs/category/working-with-formdata"}},l={},c=[{value:"stringifyAsync",id:"stringifyasync",level:2},{value:"stringifyToStream",id:"stringifytostream",level:2},{value:"parseStream",id:"parsestream",level:2}];function d(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"serializing-promises",children:"Serializing Promises"}),"\n",(0,i.jsx)(s.p,{children:"Serializing promises or values containing primises."}),"\n",(0,i.jsx)(s.h2,{id:"stringifyasync",children:"stringifyAsync"}),"\n",(0,i.jsxs)(s.p,{children:["The easiest way to serialize a promise with seria is using ",(0,i.jsx)(s.code,{children:"seria.stringifyAsync"}),"."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:'import { stringifyAsync } from "seria";\n\nconst delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));\n\nconst hero = {\n  name: Promise.resolve("Shoto Todoroki"),\n  quirk: Promise.resolve("Half-Cold Half-Hot"),\n  age: Promise.resolve(16),\n  heroName: delay(1000).then(() => Symbol.for("Shoto")),\n};\n\nconst json = seria.stringifyAsync(hero);\n'})}),"\n",(0,i.jsxs)(s.p,{children:["For most cases this is enough, ",(0,i.jsx)(s.code,{children:"stringifyAsync"})," will await all the promises found before returning the serialized value that then can be parsed back with ",(0,i.jsx)(s.code,{children:"seria.parse"}),", all the promises returned by ",(0,i.jsx)(s.code,{children:"parse"})," with be promises which value is just a ",(0,i.jsx)(s.code,{children:"Promise.resolve(value)"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["But when you are communicating between a server and client maybe you don't want your client to wait for all the promises to resolve to get the value back, for those use cases you need to use ",(0,i.jsx)(s.code,{children:"seria.stringifyToStream"})," and ",(0,i.jsx)(s.code,{children:"seria.parseStream"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"stringifytostream",children:"stringifyToStream"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"seria.stringifyToStream"})," as the name says, takes a value and returns a ",(0,i.jsx)(s.code,{children:"ReadableStream"})," which stream each value and resolved ",(0,i.jsx)(s.code,{children:"Promise"})," value."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:'import { stringifyToStream } from "seria";\n\nconst hero = {\n  name: Promise.resolve("Yu Takeyama"),\n  quirk: Promise.resolve("Gigantification"),\n  age: Promise.resolve(24),\n  heroName: delay(1000).then(() => Symbol.for("Mt. Lady")),\n};\n\nconst stream = stringifyToStream(hero);\n'})}),"\n",(0,i.jsxs)(s.p,{children:["The returting stream will stream the values, first the values ",(0,i.jsx)(s.code,{children:"name"}),", ",(0,i.jsx)(s.code,{children:"quirk"})," and ",(0,i.jsx)(s.code,{children:"age"})," and after 1000ms the value ",(0,i.jsx)(s.code,{children:"heroName"}),", to retrieve the original value back you need to use ",(0,i.jsx)(s.code,{children:"seria.parseStream"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"parsestream",children:"parseStream"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"seria.parseStream"})," as the name suggest takes a stream and deserializes it to a single value."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-ts",children:'import { parseStream } from "seria";\n\nconst stream = getStream();\nconst value = await parseStream(stream);\n'})}),"\n",(0,i.jsx)(s.admonition,{title:"What format use to send a stream?",type:"tip",children:(0,i.jsxs)(s.p,{children:["To transfer a stream from a server/client you can try use SSE ",(0,i.jsx)(s.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events",children:"(Server-Sent-Events)"}),"."]})})]})}function m(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},9779:(e,s,r)=>{r.d(s,{R:()=>a,x:()=>o});var i=r(9474);const t={},n=i.createContext(t);function a(e){const s=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(n.Provider,{value:s},e.children)}}}]);